{
    "version": "https://jsonfeed.org/version/1",
    "title": "NotionNext BLOG",
    "home_page_url": "https://chenglong.ml/",
    "description": "这是一个由NotionNext生成的站点",
    "author": {
        "name": "c",
        "url": "https://chenglong.ml"
    },
    "items": [
        {
            "content_html": "<div id=\"container\" class=\"max-w-5xl font-medium mx-auto undefined\"><main class=\"notion light-mode notion-page notion-block-61b984be35144f94a4af88427fb1dd60\"><div class=\"notion-viewport\"></div><div class=\"notion-collection-page-properties\"></div><div class=\"notion-row\"><a target=\"_blank\" rel=\"noopener noreferrer\" class=\"notion-bookmark notion-block-3daec8c93aba4122862391926dca4e91\" href=\"https://www.aliyundrive.com/s/KmJ23h9juDv\"><div><div class=\"notion-bookmark-title\">阿里云盘分享</div><div class=\"notion-bookmark-link\"><div class=\"notion-bookmark-link-icon\"><img src=\"https://img.alicdn.com/imgextra/i2/O1CN01DOYcs71v3B6bOemVM_!!6000000006116-2-tps-512-512.png\" alt=\"阿里云盘分享\" loading=\"lazy\" decoding=\"async\"/></div><div class=\"notion-bookmark-link-text\">https://www.aliyundrive.com/s/KmJ23h9juDv</div></div></div></a></div><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-cf1d693ef90c401c83812a18199fdfcd\" data-id=\"cf1d693ef90c401c83812a18199fdfcd\"><span><div id=\"cf1d693ef90c401c83812a18199fdfcd\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#cf1d693ef90c401c83812a18199fdfcd\" title=\"3.6 语句\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">3.6 语句</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-3b12e41723a547fabb53723df317fd0d\"><div>for-in语句是一种严格的迭代语句，用于枚举对象中的非符号键属性，</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-4e8afe4f5b98401aa12696af676c8926\"><div>start是一个标签，可以在后面通过break或continue语句引用。标签语句的典型应用场景是嵌套循环。</div></blockquote><div class=\"notion-callout notion-default_co notion-block-9b1ed9513f674b25b51615695612fdb8\"><div class=\"notion-page-icon-inline notion-page-icon-span\"><span class=\"notion-page-icon\" role=\"img\" aria-label=\"📝\">📝</span></div><div class=\"notion-callout-text\">label语法配合break或者continue，可在js中模拟出c语言中的goto语句的效果，不过也有大量的c开发者认为goto语句不应该被滥用。但在sveltejs中有一个典型的应用｛let a = 1; $:console.log(a);++a｝该语法实现了响应式的依赖收集，并且避免了闭包的产生</div></div><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-a7796e4ba6f94e9fa9f59680a683349b\" data-id=\"a7796e4ba6f94e9fa9f59680a683349b\"><span><div id=\"a7796e4ba6f94e9fa9f59680a683349b\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#a7796e4ba6f94e9fa9f59680a683349b\" title=\"4.1 原始值与引用值\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">4.1 原始值与引用值</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-46a303264fa544dea6c97fad4c5d7adc\"><div>原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。</div></blockquote><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-d82a6a29b1ef492c95e7823516a30a12\" data-id=\"d82a6a29b1ef492c95e7823516a30a12\"><span><div id=\"d82a6a29b1ef492c95e7823516a30a12\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#d82a6a29b1ef492c95e7823516a30a12\" title=\"7.2 迭代器模式\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">7.2 迭代器模式</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-56ca2991950847a287d5bf45fbbec28c\"><div>迭代器模式（特别是在ECMAScript这个语境下）描述了一个方案，即可以把有些结构称为“可迭代对象”（iterable），因为它们实现了正式的Iterable接口，而且可以通过迭代器Iterator消费。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-c33f8e6b207242bda3354c227f6c6f81\"><div>任何实现Iterable接口的数据结构都可以被实现Iterator接口的结构“消费”（consume）</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-bdd0e98ffbde41fb93195086de81959f\"><div>这里通过创建迭代器并调用next()方法按顺序迭代了数组，直至不再产生新值。迭代器并不知道怎么从可迭代对象中取得下一个值，也不知道可迭代对象有多大。只要迭代器到达done: true状态，后续调用next(</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-b09e38f22341403997575316f89963c3\"><div>迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-a0466a4e6a5e4c8e881a422217c01de0\"><div>“迭代器”的概念有时候容易模糊，因为它可以指通用的迭代，也可以指接口，还可以指正式的迭代器类型</div></blockquote><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-ffb24e19b6c04f01b427e832c9544118\" data-id=\"ffb24e19b6c04f01b427e832c9544118\"><span><div id=\"ffb24e19b6c04f01b427e832c9544118\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#ffb24e19b6c04f01b427e832c9544118\" title=\"7.3 生成器\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">7.3 生成器</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-1fe1f7b132eb4632baa40884dcbe6bed\"><div>生成器的形式是一个函数，函数名称前面加一个星号（＊）表示它是一个生成器。只要是可以定义函数的地方，就可以定义生成器。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-479071550d12491b9164141e7bdb7562\"><div>调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（suspended）的状态。与迭代器相似，生成器对象也实现了Iterator接口，因此具有next()方法。调用这个方法会让生成器开始或恢复执行。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-892036b0669b42dfa5c7639974669ad5\"><div>可以使用星号增强yield的行为，让它能够迭代一个可迭代对象，从而一次产出一个值</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-4cf8df26fa904a14bd9bcb3533449daf\"><div>for-of循环调用了默认迭代器（它恰好又是一个生成器函数）并产生了一个生成器对象。这个生成器对象是可迭代的，所以完全可以在迭代中使用。</div></blockquote><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-c8f5b584ce524f4bbc737b7a98091493\" data-id=\"c8f5b584ce524f4bbc737b7a98091493\"><span><div id=\"c8f5b584ce524f4bbc737b7a98091493\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#c8f5b584ce524f4bbc737b7a98091493\" title=\"7.4 小结\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">7.4 小结</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-59115a065ba1406c89dc329f4a26c833\"><div>迭代器必须通过连续调用next()方法才能连续取得值，这个方法返回一个IteratorObject。这个对象包含一个done属性和一个value属性。前者是一个布尔值，表示是否还有更多值可以访问；后者包含迭代器返回的当前值。这个接口可以通过手动反复调用next()方法来消费，也可以通过原生消费者，比如for-of循环来自动消费。</div></blockquote><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-a26261105730458dabc8c359a479a09f\" data-id=\"a26261105730458dabc8c359a479a09f\"><span><div id=\"a26261105730458dabc8c359a479a09f\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#a26261105730458dabc8c359a479a09f\" title=\"8.1 理解对象\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">8.1 理解对象</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-7b608048bd4643a19d8df33a42ca7203\"><div>属性分两种：数据属性和访问器属性。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-346278b1555f4a049b4fcc33d4852278\"><div>合并对象提供了Object.assign()方法。这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举（Object.propertyIsEnumerable()返回true）和自有（Object.hasOwnProperty()返回true）属性复制到目标对象。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-93d5585884484a089cf5a851ef9ca3f1\"><div>Object.assign()实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。换句话说，不能在两个对象间转移获取函数和设置函数。</div></blockquote><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-9a0f148c63cd44c08b7c8b82bc08769e\" data-id=\"9a0f148c63cd44c08b7c8b82bc08769e\"><span><div id=\"9a0f148c63cd44c08b7c8b82bc08769e\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#9a0f148c63cd44c08b7c8b82bc08769e\" title=\"8.2 创建对象\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">8.2 创建对象</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-cc7c380d1b3e4ad8a1c1133e531c9ecf\"><div>ES6的类都仅仅是封装了ES5.1构造函数加原型继承的语法糖而已。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-e9bda04236354d72bfc6a6ef2d47e2e9\"><div>重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。记住，实例只有指向原型的指针，没有指向构造函数的指针。</div></blockquote><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-90f07485f62b41b9a41b04024ea78401\" data-id=\"90f07485f62b41b9a41b04024ea78401\"><span><div id=\"90f07485f62b41b9a41b04024ea78401\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#90f07485f62b41b9a41b04024ea78401\" title=\"8.3 继承\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">8.3 继承</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-edf91e95bcf94d24b4c971042e1fa64d\"><div>重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-619bd56dd18f4ec983786792cdd80c2a\"><div>任何函数的默认原型都是一个Object的实例，这意味着这个实例有一个内部指针指向Object.prototype。这也是为什么自定义类型能够继承包括toString()、valueOf()在内的所有默认方法的原因。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-83ab4ed5c6f748d9bcc8c3d8bff6215a\"><div>[插图]</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-62b34ae7a8dd43d4b7e0c6f6fec833e3\"><div>为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函数”（constructor stealing）的技术在开发社区流行起来（这种技术有时也称作“对象伪装”或“经典继承”）。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-9c0d9693e88940e388b98a75557fd46a\"><div>.3.3 组合继承组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-1a472b7a90ef400585d5ec6d0bdd3f42\"><div>组合继承弥补了原型链和盗用构造函数的不足，是JavaScript中使用最多的继承模式。而且组合继承也保留了instanceof操作符和isPrototypeOf()方法识别合成对象的能力。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-bfcc4119568e44aa83b0b4d7ffd1d798\"><div>通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。</div></blockquote><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-468b9f3b153b4342818c98f6874f9b6f\" data-id=\"468b9f3b153b4342818c98f6874f9b6f\"><span><div id=\"468b9f3b153b4342818c98f6874f9b6f\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#468b9f3b153b4342818c98f6874f9b6f\" title=\"9.1 代理基础\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">9.1 代理基础</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-f0ad2e56c89f457e9e05940c31fac699\"><div>使用代理的主要目的是可以定义捕获器（trap）</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-43ebd26a5916461582aaa735bf349b02\"><div>实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局Reflect对象上（封装了原始行为）的同名方法来轻松重建。</div></blockquote><div class=\"notion-blank notion-block-05773439d9b7450b9a24b7148d1fecb0\"> </div><div class=\"notion-blank notion-block-ef27632c300e4bea8471cc6e92154403\"> </div></main></div>",
            "url": "https://chenglong.ml/article/js-red-book",
            "title": "js红宝书",
            "summary": "js",
            "date_modified": "2021-07-02T00:00:00.000Z"
        },
        {
            "content_html": "<div id=\"container\" class=\"max-w-5xl font-medium mx-auto undefined\"><main class=\"notion light-mode notion-page notion-block-c4da737ce266453daf08eb2ccb92e571\"><div class=\"notion-viewport\"></div><div class=\"notion-collection-page-properties\"></div><h3 class=\"notion-h notion-h2 notion-h-indent-0 notion-block-8841bdab410549dca1efda480ef2ecf5\" data-id=\"8841bdab410549dca1efda480ef2ecf5\"><span><div id=\"8841bdab410549dca1efda480ef2ecf5\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#8841bdab410549dca1efda480ef2ecf5\" title=\"解读\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">解读</span></span></h3><h3 class=\"notion-h notion-h2 notion-h-indent-0 notion-block-d4d483d86bc248779563897fa1b89853\" data-id=\"d4d483d86bc248779563897fa1b89853\"><span><div id=\"d4d483d86bc248779563897fa1b89853\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#d4d483d86bc248779563897fa1b89853\" title=\"关于作者\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">关于作者</span></span></h3><div class=\"notion-text notion-block-6d3f8528d5714203b67ec02438189143\">李泽厚，著名美学家、哲学家。出生于1930年的李泽厚成名很早，早在上世纪五十年代，就因一场全国性的美学大论争而崭露头角。到了80年代，李泽厚的影响远远超出了美学界，依次掀起了美学热、文化热、思想热。和一般意义上的专家、学者不同，李泽厚是一个领域异常开阔、个性异常鲜明的“思想家”，甚至没有什么“专业”，哲学、美学、社会、心理，他都涉足过；历史、政治、文学、艺术，他都研究过。\n上世纪90年代，离开中国的李泽厚也把他的影响力带到了全世界，2010年纽约NORTON 出版社的世界哲学选本，编选了148位哲学家，其中就有中国的李泽厚。古往今来，全世界的美学家仅选了13位，李泽厚也赫然在列。李泽厚的学问是学贯中西的，所以，他的影响势必是世界的。</div><h3 class=\"notion-h notion-h2 notion-h-indent-0 notion-block-3b80beeaa4154cb49fd02800dc586e69\" data-id=\"3b80beeaa4154cb49fd02800dc586e69\"><span><div id=\"3b80beeaa4154cb49fd02800dc586e69\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#3b80beeaa4154cb49fd02800dc586e69\" title=\"\n关于本书\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">\n关于本书</span></span></h3><div class=\"notion-text notion-block-394e6224a62d49a9ae2c94f97da5811b\">《哲学纲要》是李泽厚中西哲学研究的集大成之作，它集中反映了继80年代“美学热”后，李泽厚这几十年潜心研究、系统整理哲学的成果。所以，我们可以把《哲学纲要》看成一个总结性的、里程碑式的作品。\n这部书的内容主要由《伦理学纲要》《认识论纲要》《存在论纲要》三部分组成，这三部分也是哲学的三大基本范畴。在伦理学这一块，李泽厚提出道德起源于人们维护社会稳定的需要，并且逐渐被神圣化和绝对化；在认识论方面，李泽厚提出了“实用理性”这一观点，强调认识的世界的目的是服务于生活，而不是为了追求绝对的理性；最后在存在论这块，李泽厚提出了具备东方文化特色的“情本体”，提倡情感的满足才是人生的主要目的。</div><h3 class=\"notion-h notion-h2 notion-h-indent-0 notion-block-8a0e8e2a903e4508abff64ed1be9e1bb\" data-id=\"8a0e8e2a903e4508abff64ed1be9e1bb\"><span><div id=\"8a0e8e2a903e4508abff64ed1be9e1bb\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#8a0e8e2a903e4508abff64ed1be9e1bb\" title=\"\n核心内容\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">\n核心内容</span></span></h3><div class=\"notion-text notion-block-4056620060554bf3a3d7d6c73001e8ec\">美学大师李泽厚以西方哲学史的三大问题“伦理学”“认识论”“存在论”为基本框架，提出了一整套与西方哲学史不同，甚至是针锋相对的哲学体系，这个体系不仅能让中国式的生存智慧走向世界，还试图帮助我们每一个人在当代“活得更好”。\n伦理学一道德的起源与作用道德起源于人们维护稳定的需要道德产生于一定时代环境下被神化的道德对社会起到教化的作用认知论—实用理性观点存在论-情本体概念认知世界应既重视实用又理性克制人生主要目的是情感上的满足实用理性存在于儒家、墨家、道家、法家的思维方式中人生真理存在于人的生活之中这个体系让中国式生存智慧走向世界，还试图帮助我们活得更好点击查看大图，保存到手机，也可以分享到朋友圈一、道德是如何产生，如何被神圣化的最核心的问题是道德究竟是什么？道德是如何产生的？李泽厚在本书中开宗明义地说：道德是人类在具体时代环境下，为了维持人类群体的存在而制定的共同行为方式或者标准。在这个定义中，有这样两点特别值得关注。首先是道德的目的是为了维护人类群体，也就是社会的稳定和持续。另外一点是道德产生在具体时代环境下。</div><div class=\"notion-text notion-block-5b76e50da712403faa2c56ee892d91b4\">\n1. 道德的目的是为了维护人类群体\n按照李泽厚的观点，这是人类做出的一个选择，这个选择充分体现了人的自觉和理性。因为道德是服务于社会集体，而不是个体利益，甚至有时会损害个人利益。举个例子，原始社会的道德会要求个人把打猎所得都上交，但这就会妨碍他积攒个人财富。但是，这个人因为知道这个规矩是有助于维护部落的团结和稳定的，所以最终他会选择交出自己的猎物，遵循这个道德。这个观点是和西方很多伦理学家的观点相似的。\n那么人的自觉性和主动性是怎么表现出来呢？在这一点上李泽厚的观点却几乎和所有人都不同，他认为道德表现为一种特殊的心理形式，是运用自由意志做出正确决定的行为。请注意，不是外在压力下的选择，而是自由的、主动的心理过程。其他伦理学家看重道德的结果，而李泽厚却更看重道德的心理过程。</div><div class=\"notion-text notion-block-17ea279e133f4023a8910e9992962c6a\">\n2．道德产生在具体时代环境下\n我们再来说一下什么是道德产生在一定时\n代环境下的，换句话说，道德原本不是绝对的，是产生在具体的条件下，因此道德也会随着时代环境的变化而变化。比如孝顺这件事情，人们并不是从一开始就有养老、敬老的道德习惯，在一些原始部落里，甚至有杀老、弃老的事情存在。只是后来随着社会的发展，我们逐渐提出了孝顺这一道德要求。\n那么这种变化是怎么产生的？或者说道德是如何被神圣化的？作者认为教育在其中起了关键性作用。比如中国古代的科举制就使传统道德变得神圣化。在科举制的要求下，古代学子入学先学“礼”，这种原本产生在具体社会条件下的儒家传统，如今却通过教育的方式被固定下来，而且随着教育的不断深入而逐渐深化。当道德以教条的形式出现在课堂的时候，它就具备了神圣性。比如我们或许都有这样的经验，那就是小时候对写在课本上的东西深信不疑，认为是绝对正确的，而且是崇高的，不可冒犯的。所以，教育成了道德神圣化的最好途径。在经过一干多年的教育之后，来自儒家的道德观念终于成为根深蒂固的观念，而且被权威化，绝对化，成为信仰。道德的原本意义自此发生了变化。\n作者发现了道德的变化后，进一步提出了“社会性道德”和“宗教性道德”两个概念，来区分两种不同的道德。社会性道德更符合道德的本意，强调道德的社会性，是具体社会环境下的产物。而宗教性道德就是那种被神圣化的道德观念。</div><h3 class=\"notion-h notion-h2 notion-h-indent-0 notion-block-7dca17dbd4dc4a35b5505ad37c8eeaff\" data-id=\"7dca17dbd4dc4a35b5505ad37c8eeaff\"><span><div id=\"7dca17dbd4dc4a35b5505ad37c8eeaff\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#7dca17dbd4dc4a35b5505ad37c8eeaff\" title=\"\n二、实用理性的形成\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">\n二、实用理性的形成</span></span></h3><div class=\"notion-text notion-block-c660714770cf4bff95c6beb30905ef1b\">实用理性这个词，不是西方的实用主义和理性主义这两种主义的结合，它更像是中国哲学诞生的一个幽灵概念，既无迹可寻，又无处不在。\n具体来说，实用理性是分为两部分的：首先它很少作纯粹的抽象的思辨，反而关注现实生活，事事强调实际、实用，以解决问题为主要目的。这听起来很像是实用主义，什么有用就用什么呗，还真不完全是，实用理性既强调实用，又强调理性，这也是我们要说的第二部分，实用理性主张以理节情的行为模式，也就是不让非理性的情欲横行的意思。这个理性主要指君子德、天道等，它规范、制约着实用性不能乱来。同时也以理性克制非理性的欲望。总体来说，实用理性是对人生世事采取一种既乐观进取又清醒冷静的思维态度。\n实用理性这个概念是李泽厚独创的说法。他认为实用理性是中国人认识世界、做人处事独特的思维方式，决定了我们的文化心理。中国人就靠这个生生不息，同时和世界其他民族不一样。\n为了证明实用理性是中国独有的一种思维方式，李泽厚对中国文化传统做了一个梳理。他将实用理性和儒家、道家、墨家等学说都联系起来。\n我们再补充一点，实用理性和西方的纯粹理性是怎么不同的？这里最大的区别在于实用理性既强调理性，又强调生活，而且，生活大于理性，理性是为生活服务的。但是西方的纯粹理性是怎么说的呢？比如，黑格尔的绝对精神，它是指不考虑具体历史，认为必然存在着一种绝对的理性；或者说柏拉图的理念世界，这也是不考虑现实世界，认为必然存在着一种先天的理性；再比如胡塞尔的纯粹意识，这是指不考虑人类大脑，认为必然存在着一种独立的理性。这些理性都是李泽厚先生所批评的，他认为中国的实用理性是历史地形成的，它帮助我们解决了如何认识世界、如何活的问题，而且这也是我们的政治智慧的来源，比如改革开放时期的黑猫白猫论，就是最典型的例子。</div><h3 class=\"notion-h notion-h2 notion-h-indent-0 notion-block-dcb39f61a2764810b61b58094dee6c63\" data-id=\"dcb39f61a2764810b61b58094dee6c63\"><span><div id=\"dcb39f61a2764810b61b58094dee6c63\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#dcb39f61a2764810b61b58094dee6c63\" title=\"\n三、“情本体”的具体含义，以及与西方哲学的区别\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">\n三、“情本体”的具体含义，以及与西方哲学的区别</span></span></h3><div class=\"notion-text notion-block-14a7e17eb38842958d1aa299ee661079\">存在论研究的是人活着应该追求一个什么样的终极目的。那么在李泽厚看来，人该以什么为目的呢？为了回答这个终极问题，李泽厚提出了“情本体”这个概念，本体就是本质、本原、根本的意思。情本体，就是说我们把情感的满足放在人生意义的第一位，主张以情感为根本目的，人才能活得好。\n事实上，围绕着“怎样活得好”这个问题，西方哲学不断地探索，并给出了各种答案。比如，上帝能让人活得好，这就是基督教的存在论；道德能让人活得好，这就是道德主义的存在论；语言逻辑能让人活得好，这就是分析哲学的存在论；欲望满足能让人活得好，这就是快乐哲学的存在能让人活得好，这就是快乐哲学的存在论；真理能让人活得好，这就是理性主义的存在论；最后，康德、黑格尔等甚至提出了美，认为美能让人活得更好，由此诞生了一门学科，这就是美学。\n但是李泽厚认为，我们需要一种独属于中国传统的生活观，所以他提出了“情本体”的概念。李泽厚之所以强调情的重要性，是因为他看到了情的本质。那就是这种情感实际上来源于人的各种动物本能，比如性本能，或者求生本能。但这种本能大多不便于直接发泄出来，所以人们会将这种本能转化或者提升，具体的方式就是创造理性化的，容易被人接受的人伦关系，而情感就是在这些人伦关系中产生的。换句话说，情感是人本能的衍生，是人生最真实的东西，最能切身感受到的。所以当讨论到人生意义或者目的的时候，绝不能忽视情感。\n而相对于情感，不管是宗教，还是理性，都是一种先验的存在。也就是说，他们是人生之外的东西，是超越于现实生活之上的，而且还是强加给人，不是从人内在最本质的需求出发的。所以，李泽厚的“情本体”实际上是对人的一种肯定，换言之，也是对现世生活的一种肯定。\n为了具体表现这种对现世生活的肯定，李泽厚举了孔子的例子。故事是说有人问子路，孔子到底是一个什么样的人，子路觉\n得太难以概括了，所以就没有回答。后来孔子知道了这件事，就自己总结道：我这\n个人啊，发愤读书，乐以忘忧，甚至都不知道自己快要老了。李泽厚从这个例子中总结出孔子实际上是一个很欢乐的人，这种欢乐主要体现在对现实生活的珍惜和享受上。\n我们可以看出，李泽厚的“情本体”从对人的情感上肯定，延伸到对人世俗生活的肯定，他把这一切当成人的目的。这种观点传达出这样一种最简单，却最真实可靠的信息：不要去超越人世之外的地方去寻求人生的真理，因为人生真相就在我们的生活之中，在柴米油盐之中，在七情六欲之中。感受生活，追求情感的满足，这才是人的终极目的。而所谓绝对的真理，或者宗教，终究是有些虚无缥缈的，是拒绝现实生活的，如果把这些当成人的目的，很可能终其一生，追求的不过是一抹若有若无的影子。\n情本体是李泽厚先生的创造，也是中国哲学关于“存在论”的回答和交代，他提出这个概念，很大程度上是与西方哲学对抗的。\n<b>金句</b>\n<span class=\"notion-blue\">1．道德表现为一种特殊的心理形式，是运用自由意志做出正确决定的行为。\n2．道德分两种，一种是社会性道德，称之为“低度道德”，一种是宗教性道德，称之为“高度道德”。\n3．实用理性这个词，不是西方的实用主义和理性主义这两种主义的结合，它更像是中国哲学诞生的一个幽灵概念，既无迹可寻，又无处不在。</span></div><div class=\"notion-text notion-block-e441e05c716241edbf5d5dd902dca134\"><span class=\"notion-blue\">4．不要去超越人世之外的地方去寻求人生的真理，因为人生真相就在我们的生活之\n中，在柴米油盐之中，在七情六欲之中。\n5．《道德经》的辩证法逐渐被人运用于生活中，实用的色彩愈演愈烈。</span></div></main></div>",
            "url": "https://chenglong.ml/article/outline-of-philosophy",
            "title": "《哲学纲要》",
            "summary": "知乎年度书籍-《哲学纲要》是李泽厚中西哲学研究的集大成之作，它集中反映了继80年代“美学热”后…",
            "date_modified": "2023-03-02T00:00:00.000Z"
        },
        {
            "content_html": "<div id=\"container\" class=\"max-w-5xl font-medium mx-auto undefined\"><main class=\"notion light-mode notion-page notion-block-29d1ffb879c446dd95223ce94433a2c5\"><div class=\"notion-viewport\"></div><div class=\"notion-collection-page-properties\"></div><div class=\"notion-row\"><a target=\"_blank\" rel=\"noopener noreferrer\" class=\"notion-bookmark notion-block-02378dd718f849df9faea6a048974cb8\" href=\"https://www.aliyundrive.com/s/sBKA6LfXtyf\"><div><div class=\"notion-bookmark-title\">阿里云盘分享</div><div class=\"notion-bookmark-link\"><div class=\"notion-bookmark-link-icon\"><img src=\"https://img.alicdn.com/imgextra/i2/O1CN01DOYcs71v3B6bOemVM_!!6000000006116-2-tps-512-512.png\" alt=\"阿里云盘分享\" loading=\"lazy\" decoding=\"async\"/></div><div class=\"notion-bookmark-link-text\">https://www.aliyundrive.com/s/sBKA6LfXtyf</div></div></div></a></div><h4 class=\"notion-h notion-h3 notion-default notion-h-indent-0 notion-block-ee9d1cb0aad648bbb646c95acf15ecdf\" data-id=\"ee9d1cb0aad648bbb646c95acf15ecdf\"><span><div id=\"ee9d1cb0aad648bbb646c95acf15ecdf\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#ee9d1cb0aad648bbb646c95acf15ecdf\" title=\"1.2 理解作用域\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">1.2 理解作用域</span></span></h4><blockquote class=\"notion-quote notion-default notion-block-bcad261104874ae4be033aebb943a208\"><div>引擎从头到尾负责整个JavaScript程序的编译及执行过程。· 编译器引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-455e6f1fbd6949d684a2a090312f683c\"><div>· 作用域引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-b49ac261699a4108bcc33c81a18efffe\"><div>变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-3b9522ccc80943359a08b0f069e08813\"><div>RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图找到变量的容器本身</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-5c605c07b3464cb180c8a423fe5bb95b\"><div>LHS和RHS的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）</div></blockquote><h4 class=\"notion-h notion-h3 notion-default notion-h-indent-0 notion-block-facbe11de520445ba249249a6e4196b6\" data-id=\"facbe11de520445ba249249a6e4196b6\"><span><div id=\"facbe11de520445ba249249a6e4196b6\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#facbe11de520445ba249249a6e4196b6\" title=\"1.3 作用域嵌套\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">1.3 作用域嵌套</span></span></h4><blockquote class=\"notion-quote notion-default notion-block-a2d0a7b0592c4d91b8d9d6da8d3ad3e5\"><div>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。</div></blockquote><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-055b6bf539224c098ac4b1ea04ed24f6\" data-id=\"055b6bf539224c098ac4b1ea04ed24f6\"><span><div id=\"055b6bf539224c098ac4b1ea04ed24f6\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#055b6bf539224c098ac4b1ea04ed24f6\" title=\"第2章 词法作用域\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">第2章 词法作用域</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-f430824e69e344bd8f2bedc7338cb832\"><div>作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域，我们会对这种作用域进行深入讨论。另外一种叫作动态作用域，仍有一些编程语言在使用（比如Bash脚本、Perl中的一些模式等）。</div></blockquote><h4 class=\"notion-h notion-h3 notion-default notion-h-indent-1 notion-block-0c13cb01c9164bdeba9147870139f270\" data-id=\"0c13cb01c9164bdeba9147870139f270\"><span><div id=\"0c13cb01c9164bdeba9147870139f270\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#0c13cb01c9164bdeba9147870139f270\" title=\"2.1 词法阶段\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">2.1 词法阶段</span></span></h4><blockquote class=\"notion-quote notion-default notion-block-7f8b8efefb764b40990e92ad02c98355\"><div>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-d27c62263acd43a5be03536d8deb0028\"><div>事实上，让词法作用域根据词法关系保持书写时的自然关系不变，是一个非常好的最佳实践。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-d8a58bd9419b41779501a5e0e1a515e7\"><div>没有任何函数的气泡可以（部分地）同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样。</div></blockquote><h4 class=\"notion-h notion-h3 notion-default notion-h-indent-1 notion-block-a42f46800f9e48f5b136a196de0c35f2\" data-id=\"a42f46800f9e48f5b136a196de0c35f2\"><span><div id=\"a42f46800f9e48f5b136a196de0c35f2\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#a42f46800f9e48f5b136a196de0c35f2\" title=\"2.2 欺骗词法\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">2.2 欺骗词法</span></span></h4><blockquote class=\"notion-quote notion-default notion-block-a39000a423ae41589c97f5d039bb8767\"><div>欺骗词法</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-268b8b76710842eea2592e9a737e6004\"><div>欺骗词法作用域会导致性能下降。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-f4c9d7fe7d634b4ea7580b08a86a27eb\"><div>JavaScript中的eval(..)函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-b45a721661b1410eb01aa2896a2f3fa6\"><div>eval(..)调用中的&quot;var b = 3; &quot;这段代码会被当作本来就在那里一样来处理。由于那段代码声明了一个新的变量b，因此它对已经存在的foo(..)的词法作用域进行了修改。事实上，和前面提到的原理一样，这段代码实际上在foo(..)内部创建了一个变量b，并遮蔽了外部（全局）作用域中的同名变量。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-a5d4aac8f3a54851bef6703e602bd117\"><div>with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。</div></blockquote><h4 class=\"notion-h notion-h3 notion-default notion-h-indent-1 notion-block-8f2f7536f91f4a5380334e38d7136d9e\" data-id=\"8f2f7536f91f4a5380334e38d7136d9e\"><span><div id=\"8f2f7536f91f4a5380334e38d7136d9e\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#8f2f7536f91f4a5380334e38d7136d9e\" title=\"2.3 小结\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">2.3 小结</span></span></h4><blockquote class=\"notion-quote notion-default notion-block-473e5284581d4e508395b065469f535e\"><div>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。</div></blockquote><h4 class=\"notion-h notion-h3 notion-default notion-h-indent-1 notion-block-19ca525b31ff4cc8a16a8e129964c772\" data-id=\"19ca525b31ff4cc8a16a8e129964c772\"><span><div id=\"19ca525b31ff4cc8a16a8e129964c772\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#19ca525b31ff4cc8a16a8e129964c772\" title=\"3.1 函数中的作用域\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">3.1 函数中的作用域</span></span></h4><blockquote class=\"notion-quote notion-default notion-block-31d9def168424db0ba2277ce2e772281\"><div>JavaScript具有基于函数的作用域，意味着每声明一个函数都会为其自身创建一个气泡，而其他结构都不会创建作用域气泡。但事实上这并不完全正确，下面我们来看一下</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-a5fe186ab29145b9b571c24b12b00efc\"><div>无论标识符声明出现在作用域中的何处，这个标识符所代表的变量或函数都将附属于所处作用域的气泡</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-a62e54e22ffc475e841e0580615bae4c\"><div>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）</div></blockquote><h4 class=\"notion-h notion-h3 notion-default notion-h-indent-1 notion-block-6576d395983b4935a102197df94977f5\" data-id=\"6576d395983b4935a102197df94977f5\"><span><div id=\"6576d395983b4935a102197df94977f5\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#6576d395983b4935a102197df94977f5\" title=\"3.2 隐藏内部实现\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">3.2 隐藏内部实现</span></span></h4><blockquote class=\"notion-quote notion-default notion-block-34579d6c7db04f0e866367e0e58c7e0a\"><div>有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-2b62021bd08c4d5383e325c4a8699066\"><div>“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-9ee1149ef6004e2384e6e686e5081353\"><div>bar(..)内部的赋值表达式i = 3意外地覆盖了声明在foo(..)内部for循环中的i。在这个例子中将会导致无限循环，因为i被固定设置为3，永远满足小于10这个条件。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-2f8d0cb5e7a14eb58b77f4770da6e8fa\"><div>这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-f3a7fe63031c4b46a5a798129b1efb63\"><div>另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。</div></blockquote><h4 class=\"notion-h notion-h3 notion-default notion-h-indent-1 notion-block-e58002a95ff64264a176a5c68ed75d15\" data-id=\"e58002a95ff64264a176a5c68ed75d15\"><span><div id=\"e58002a95ff64264a176a5c68ed75d15\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#e58002a95ff64264a176a5c68ed75d15\" title=\"3.3 函数作用域\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">3.3 函数作用域</span></span></h4><blockquote class=\"notion-quote notion-default notion-block-54295e8183b94653a511c4e96f54bda0\"><div>在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-30fb5a9041ae471eac05aec029b76403\"><div>首先，必须声明一个具名函数foo()，意味着foo这个名称本身“污染”了所在作用域（在这个例子中是全局作用域）。其次，必须显式地通过函数名（foo()）调用这个函数才能运行其中的代码。如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-b37e6b6b26414e97b3357f04256fa74d\"><div>函数会被当作函数表达式而不是一个标准的函数声明来处理。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-c27df5feb7de4b16af2dc1906b3da298\"><div>区分函数声明和表达式最简单的方法是看function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-50769b60f8834a59a18a7ee11feaa14e\"><div>立即执行函数表达式</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-27b76208b100447a954df022ec1aa28d\"><div>函数名对IIFE当然不是必须的，IIFE最常见的用法是使用一个匿名函数表达式。虽然使用具名函数的IIFE并不常见，但它具有上述匿名函数表达式的所有优势，因此也是一个值得推广的实践。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-3aa74c252a314e989c8a686f4e19716a\"><div>IIFE还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去</div></blockquote><h4 class=\"notion-h notion-h3 notion-default notion-h-indent-1 notion-block-807e431a95d84c288bc0ad1ce00676f6\" data-id=\"807e431a95d84c288bc0ad1ce00676f6\"><span><div id=\"807e431a95d84c288bc0ad1ce00676f6\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#807e431a95d84c288bc0ad1ce00676f6\" title=\"3.4 块作用域\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">3.4 块作用域</span></span></h4><blockquote class=\"notion-quote notion-default notion-block-711ec380c0664842bb55175ef7b54b5c\"><div>我们在for循环的头部直接定义了变量i，通常是因为只想在for循环内部的上下文中使用i，而忽略了i会被绑定在外部作用域（函数或全局）中的事实。</div></blockquote><h4 class=\"notion-h notion-h3 notion-default notion-h-indent-1 notion-block-bd86ae3fdc754237940782558fc07338\" data-id=\"bd86ae3fdc754237940782558fc07338\"><span><div id=\"bd86ae3fdc754237940782558fc07338\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#bd86ae3fdc754237940782558fc07338\" title=\"4.2 编译器再度来袭\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">4.2 编译器再度来袭</span></span></h4><blockquote class=\"notion-quote notion-default notion-block-0594a9ea80114ab7995bebd233790b87\"><div>foo函数的声明（这个例子还包括实际函数的隐含值）被提升了</div></blockquote><h4 class=\"notion-h notion-h3 notion-default notion-h-indent-1 notion-block-20a4822aa8244d52bbb930c366ba571e\" data-id=\"20a4822aa8244d52bbb930c366ba571e\"><span><div id=\"20a4822aa8244d52bbb930c366ba571e\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#20a4822aa8244d52bbb930c366ba571e\" title=\"4.3 函数优先\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">4.3 函数优先</span></span></h4><blockquote class=\"notion-quote notion-default notion-block-92e44e8556ea47faaa2ebd07759a1474\"><div>函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-bfd741b78c7146f084f1bf61e394ca60\"><div>一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代码暗示的那样可以被条件判断所控制：</div></blockquote><h4 class=\"notion-h notion-h3 notion-default notion-h-indent-1 notion-block-a74f31e403674a22a3c6e7a8ef02c858\" data-id=\"a74f31e403674a22a3c6e7a8ef02c858\"><span><div id=\"a74f31e403674a22a3c6e7a8ef02c858\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#a74f31e403674a22a3c6e7a8ef02c858\" title=\"5.1 启示\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">5.1 启示</span></span></h4><blockquote class=\"notion-quote notion-default notion-block-f5305b06513a4f5aa6e65411f9b3648c\"><div>JavaScript中闭包无处不在，你只需要能够识别并拥抱它。闭包并不是一个需要学习新的语法或模式才能使用的工具，它也不是一件必须接受像Luke[插图]一样的原力训练才能使用和掌握的武器。闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。</div></blockquote><h4 class=\"notion-h notion-h3 notion-default notion-h-indent-1 notion-block-95e7c5e0747047dbab74cb4be33c148f\" data-id=\"95e7c5e0747047dbab74cb4be33c148f\"><span><div id=\"95e7c5e0747047dbab74cb4be33c148f\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#95e7c5e0747047dbab74cb4be33c148f\" title=\"5.2 实质问题\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">5.2 实质问题</span></span></h4><blockquote class=\"notion-quote notion-default notion-block-b8bbf0f2197c403b9b1bb379efbcd6d0\"><div>在foo()执行后，通常会期待foo()的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去foo()的内容不会再被使用，所以很自然地会考虑对其进行回收。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-324f7c8282bc4965ac4bab3fc2df35b2\"><div>bar()依然持有对该作用域的引用，而这个引用就叫作闭包。</div></blockquote><h4 class=\"notion-h notion-h3 notion-default notion-h-indent-1 notion-block-872be750975b4553a54eec8fd6eac420\" data-id=\"872be750975b4553a54eec8fd6eac420\"><span><div id=\"872be750975b4553a54eec8fd6eac420\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#872be750975b4553a54eec8fd6eac420\" title=\"5.3 现在我懂了\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">5.3 现在我懂了</span></span></h4><blockquote class=\"notion-quote notion-default notion-block-9ca26f66a59647fe80b04928ae0edb6c\"><div>将一个内部函数（名为timer）传递给setTimeout(..)。timer具有涵盖wait(..)作用域的闭包，因此还保有对变量message的引用。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-d282defd1a2c4adea81a47a7f63e6336\"><div>在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-eb1e4cf6bc0d41f599f03084ea25854b\"><div>因为函数（示例代码中的IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行（而外部作用域，也就是全局作用域也持有a）。a是通过普通的词法作用域查找而非闭包被发现的。</div></blockquote><h4 class=\"notion-h notion-h3 notion-default notion-h-indent-1 notion-block-adc8623add144f65ae0cb241310250f1\" data-id=\"adc8623add144f65ae0cb241310250f1\"><span><div id=\"adc8623add144f65ae0cb241310250f1\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#adc8623add144f65ae0cb241310250f1\" title=\"5.4 循环和闭包\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">5.4 循环和闭包</span></span></h4><blockquote class=\"notion-quote notion-default notion-block-605b1f8ec0364682ac5d21ccd3b7b21a\"><div>在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。</div></blockquote><h4 class=\"notion-h notion-h3 notion-default notion-h-indent-1 notion-block-c72cd4913e864661baff1ed950e56302\" data-id=\"c72cd4913e864661baff1ed950e56302\"><span><div id=\"c72cd4913e864661baff1ed950e56302\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#c72cd4913e864661baff1ed950e56302\" title=\"5.6 小结\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">5.6 小结</span></span></h4><blockquote class=\"notion-quote notion-default notion-block-041a0e9ae9fb4f14bc8963f1e644e3a1\"><div>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。</div></blockquote><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-89d6bf23e2ff43dd90d3d6cc4662e7f2\" data-id=\"89d6bf23e2ff43dd90d3d6cc4662e7f2\"><span><div id=\"89d6bf23e2ff43dd90d3d6cc4662e7f2\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#89d6bf23e2ff43dd90d3d6cc4662e7f2\" title=\"附录A 动态作用域\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">附录A 动态作用域</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-b937da35d01c454982eb38093359e907\"><div>主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。（this也是！）词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</div></blockquote><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-9299a97495e34e089e82ab6c982090e9\" data-id=\"9299a97495e34e089e82ab6c982090e9\"><span><div id=\"9299a97495e34e089e82ab6c982090e9\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#9299a97495e34e089e82ab6c982090e9\" title=\"附录B 块作用域的替代方案\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">附录B 块作用域的替代方案</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-27f447e5d24749ef83f72082eb96bcce\"><div>Google维护着一个名为Traceur的项目，该项目正是用来将ES6代码转换成兼容ES6之前的环境（大部分是ES5，但不是全部）。</div></blockquote><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-b281e5ddd9c54545a9adecb5e3dde02f\" data-id=\"b281e5ddd9c54545a9adecb5e3dde02f\"><span><div id=\"b281e5ddd9c54545a9adecb5e3dde02f\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#b281e5ddd9c54545a9adecb5e3dde02f\" title=\"附录C this词法\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">附录C this词法</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-7be28936902045e7a2c40d1b30873c1c\"><div>问题在于cool()函数丢失了同this之间的绑定。解决这个问题有好几种办法，但最常用的就是var self = this;。</div></blockquote><div class=\"notion-blank notion-block-30e6f97d17c24cf8a8f2afe70d0fc872\"> </div><div class=\"notion-blank notion-block-254f57bef0af43efbd4851211d3df971\"> </div></main></div>",
            "url": "https://chenglong.ml/article/js-know-1",
            "title": "你不知道的JavaScript（上卷）",
            "summary": "js",
            "date_modified": "2021-11-11T00:00:00.000Z"
        },
        {
            "content_html": "<div id=\"container\" class=\"max-w-5xl font-medium mx-auto undefined\"><main class=\"notion light-mode notion-page notion-block-6d4fcfa5c31347768116afe10e6a0c63\"><div class=\"notion-viewport\"></div><div class=\"notion-collection-page-properties\"></div><div class=\"notion-row\"><a target=\"_blank\" rel=\"noopener noreferrer\" class=\"notion-bookmark notion-block-fad7985ac7c14f319e82038db71bb07b\" href=\"https://www.aliyundrive.com/s/5K8D7g6dUaQ\"><div><div class=\"notion-bookmark-title\">阿里云盘分享</div><div class=\"notion-bookmark-link\"><div class=\"notion-bookmark-link-icon\"><img src=\"https://img.alicdn.com/imgextra/i2/O1CN01DOYcs71v3B6bOemVM_!!6000000006116-2-tps-512-512.png\" alt=\"阿里云盘分享\" loading=\"lazy\" decoding=\"async\"/></div><div class=\"notion-bookmark-link-text\">https://www.aliyundrive.com/s/5K8D7g6dUaQ</div></div></div></a></div><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-ffde2e9d5c5b42de987d84f36088904a\" data-id=\"ffde2e9d5c5b42de987d84f36088904a\"><span><div id=\"ffde2e9d5c5b42de987d84f36088904a\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#ffde2e9d5c5b42de987d84f36088904a\" title=\"第1章 类型\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">第1章 类型</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-e822d64c69c74e1b9c0a0ab4a6cb5144\"><div>本规范中的运算法则所操纵的值均有相应的类型。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-a104216b894d477c84e7e57b9da2437b\"><div>ECMAScript语言类型包括Undefined、Null、Boolean、String、Number和Object。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-bf122abf9c684aec8f2a1d12aed8adc9\"><div>function（函数）也是JavaScript的一个内置类型。然而查阅规范就会知道，它实际上是object的一个“子类型”。具体来说，函数是“可调用对象”，它有一个内部属性[[Call]]，该属性使其可以被调用。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-db45643b17934068a39e70d02544a34f\"><div>函数对象的length属性是其声明的参数的个数：</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-902192857d67425fb481b6f654de482d\"><div>数组也是对象。确切地说，它也是object的一个“子类型”</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-58e29bd185194046986595ed5c02f822\"><div>JavaScript中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-86e7100f2978498292af013904dbd70e\"><div>语言引擎不要求变量总是持有与其初始值同类型的值</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-11ce316a849742e89b509193cf734263\"><div>在对变量执行typeof操作时，得到的结果并不是该变量的类型，而是该变量持有的值的类型，因为JavaScript中的变量没有类型。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-b22cdacf44b74fbca4022adab3a04e32\"><div>已在作用域中声明但还没有赋值的变量，是undefined的。相反，还没有在作用域中声明过的变量，是undeclared的。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-732898056a554a7d89e35058b70a0922\"><div>问题是如何在程序中检查全局变量DEBUG才不会出现ReferenceError错误。这时typeof的安全防范机制就成了我们的好帮手</div></blockquote><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-5ab59265576240cead3b5cdfd52fd523\" data-id=\"5ab59265576240cead3b5cdfd52fd523\"><span><div id=\"5ab59265576240cead3b5cdfd52fd523\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#5ab59265576240cead3b5cdfd52fd523\" title=\"第2章 值\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">第2章 值</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-a673a1b0b947426cb7f469435d474dbd\"><div>使用delete运算符可以将单元从数组中删除，但是请注意，单元删除后，数组的length属性并不会发生变化。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-d64d8bbce22e426c925a3b939aa5b7dc\"><div>在创建“稀疏”数组（sparse array，即含有空白或空缺单元的数组）时要特别注意：</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-f36eeaa78cd7497ab0b488ede76348b4\"><div>上面的代码可以正常运行，但其中的“空白单元”（empty slot）可能会导致出人意料的结果。a[1]的值为undefined，但这与将其显式赋值为undefined（a[1] = undefined）还是有所区别。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-01a61c9fbad74b1f8da79d301419a406\"><div>数组通过数字进行索引，但有趣的是它们也是对象，所以也可以包含字符串键值和属性（但这些并不计算在数组长度内）：</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-f237a1f55bed486ab878b702440289e0\"><div>如果字符串键值能够被强制类型转换为十进制数字的话，它就会被当作数字索引来处理。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-7a653eb8976441c7b06b41ce12057144\"><div>有时需要将类数组（一组通过数字索引的值）转换为真正的数组，这一般通过数组工具函数（如indexOf(..)、concat(..)、forEach(..)等）来实现。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-3bcb69d68374499daf1b524d34dc4003\"><div>JavaScript中的数字类型是基于IEEE 754标准来实现的，该标准通常也被称为“浮点数”。JavaScript使用的是“双精度”格式（即64位二进制）。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-3011649e65144f16b18388ae48bb0d0d\"><div>从ES6开始，该值定义在Number.EPSILON中，我们可以直接拿来用，</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-42f013927dd043d995927fff814b25fc\"><div>a | 0可以将变量a中的数值转换为32位有符号整数，因为数位运算符|只适用于32位整数（它只关心32位以内的值，其他的数位将被忽略）。因此与0进行OR操作本质上没有意义。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-0b855579a2a549e495fe2062e74df746\"><div>JavaScript中的引用和其他语言中的引用/指针不同，它们不能指向别的变量/引用，只能指向值。</div></blockquote><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-649fc0d66fdd4eefa78ea0b43a518087\" data-id=\"649fc0d66fdd4eefa78ea0b43a518087\"><span><div id=\"649fc0d66fdd4eefa78ea0b43a518087\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#649fc0d66fdd4eefa78ea0b43a518087\" title=\"第3章 原生函数\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">第3章 原生函数</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-fb4620c81ef144c1a84b2346e3d8ebbb\"><div>通过构造函数（如new String(&quot;abc&quot;)）创建出来的是封装了基本类型值（如&quot;abc&quot;）的封装对象。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-b3771c4b3f7549799c58c8f1703a6c64\"><div>new String(&quot;abc&quot;)创建的是字符串&quot;abc&quot;的封装对象，而非基本类型值&quot;abc&quot;</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-289c9834041a4b4fbaef50518c9d1b7b\"><div>所有typeof返回值为&quot;object&quot;的对象（如数组）都包含一个内部属性[[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过Object.prototype.toString(..)来查看。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-799c9e838ed84c87a403f3fbef3b1c3f\"><div>基本类型值没有．length和．toString()这样的属性和方法，需要通过封装对象才能访问，此时JavaScript会自动为基本类型值包装（box或者wrap）一个封装对象</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-d92c52ecc139492da251eea5ac9d1627\"><div>我们为false创建了一个封装对象，然而该对象是真值（“truthy”，即总是返回true，参见第4章），所以这里使用封装对象得到的结果和使用false截然相反。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-95c32fd035b44efe88128ea9187fd1a9\"><div>关键字。不带时，它会被自动补上。因此Array(1,2,3)和new Array(1,2,3)的效果是一样的。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-323cc6ec98aa4353aed42405616aed6f\"><div>从ES5规范开始就允许在列表（数组值、属性列表等）末尾多加一个逗号（在实际处理中会被忽略不计）。所以如果你在代码或者调试控制台中输入[ , , , ]，实际得到的是[ , , ]（包含三个空单元的数组）。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-819d3bf6496c4585a9b79077534691d7\"><div>我们可以通过下述方式来创建包含undefined单元（而非“空单元”）的数组：        var a = Array.apply( null, { length: 3 } );        a; // [ undefined, undefined, undefined ]</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-2a5d1ff6f51a48fabef556b294e92123\"><div>apply(..)是一个工具函数，适用于所有函数对象，它会以一种特殊的方式来调用传递给它的函数。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-6a232ffa7579407a96ba2df3d2bba227\"><div>除非万不得已，否则尽量不要使用Object(..)/Function(..)/RegExp(..)：</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-28f568119f3b46fdb12bb0ae8d91e487\"><div>强烈建议使用常量形式（如/^a＊b+/g）来定义正则表达式，这样不仅语法简单，执行效率也更高，因为JavaScript引擎在代码执行前会对它们进行预编译和缓存。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-6cf42473eca741afb9f0d7d754970aa2\"><div>符号是具有唯一性的特殊值（并非绝对），用它来命名对象属性不容易导致重名。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-ea9b9a99b2034355b5339daf6deddfce\"><div>符号可以用作属性名，但无论是在代码还是开发控制台中都无法查看和访问它的值，只会显示为诸如Symbol(Symbol.create)这样的值。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-82b331c712f043b3a7da702efd765932\"><div>我们可以使用Symbol(..)原生构造函数来自定义符号。但它比较特殊，不能带new关键字，否则会出错</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-382c6fd272614eb2b99fb1292441e62c\"><div>符号并非对象，而是一种简单标量基本类型。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-8a70db06a79949989cae8c97606bdae3\"><div>原生构造函数有自己的．prototype对象，如Array.prototype、String.prototype等。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-0214b19ffcb14ef1ab6bc87799798d9c\"><div>以上方法并不改变原字符串的值，而是返回一个新字符串。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-f79ad074fb914343b9066008e4542c5e\"><div>所有的函数都可以调用Function.prototype中的apply(..)、call(..)和bind(..)。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-b4d399ffb7654cb9a0d1b84dd77f41a9\"><div>Function.prototype是一个函数，RegExp.prototype是一个正则表达式，而Array. prototype是一个数组。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-f775e4c358f84d56959df154310e4423\"><div>Function.prototype是一个空函数，RegExp.prototype是一个“空”的正则表达式（无任何匹配），而Array.prototype是一个空数组。对未赋值的变量来说，它们是很好的默认值。例如：</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-714ea143f7c0434492a4d924210e0616\"><div>这种方法的一个好处是．prototype已被创建并且仅创建一次。相反，如果将[]、function(){}和/(? :)/作为默认值，则每次调用isThisCool(..)时它们都会被创建一次（具体创建与否取决于JavaScript引擎，稍后它们可能会被垃圾回收），这样无疑会造成内存和CPU资源的浪费。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-3ff5a54aab174f38877aa9c00d48e1e6\"><div>对于简单标量基本类型值，比如&quot;abc&quot;，如果要访问它的length属性或String.prototype方法，JavaScript引擎会自动对该值进行封装（即用相应类型的封装对象来包装它）来实现对这些属性和方法的访问。</div></blockquote><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-030e8ed56f6a45818676b8f520376a88\" data-id=\"030e8ed56f6a45818676b8f520376a88\"><span><div id=\"030e8ed56f6a45818676b8f520376a88\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#030e8ed56f6a45818676b8f520376a88\" title=\"第4章 强制类型转换\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">第4章 强制类型转换</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-6d0522d6b4bc45dda1637461529d8638\"><div>隐式的情况称为强制类型转换（coercion）</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-62a77483aeb04d1db7cee5406b27b1aa\"><div>JavaScript中的强制类型转换总是返回标量基本类型值（参见第2章），如字符串、数字和布尔值，不会返回对象和函数。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-7380df03410843ca820536f967d2e680\"><div>对普通对象来说，除非自行定义，否则toString()（Object.prototype.toString()）返回内部属性[[Class]]的值（参见第3章），如&quot;[object Object]&quot;。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-200df33af0224778b9675b89909d9a05\"><div>将对象强制类型转换为string是通过ToPrimitive抽象操作来完成的</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-aacb962ddf504043836e4813871f742a\"><div>工具函数JSON.stringify(..)在将JSON对象序列化为字符串时也用到了ToString。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-28b83aed6d734e6295210b5b9ba2d5a1\"><div>对大多数简单值来说，JSON字符串化和toString()的效果基本相同，只不过序列化的结果总是字符串：</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-a566367066c5432d81565f199509d2f8\"><div>JSON.stringify(..)在对象中遇到undefined、function和symbol时会自动将其忽略，在数组中则会返回null（以保证单元位置不变）。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-62e64befc7a34dda86d383b87aeb6d04\"><div>如果要对含有非法JSON值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义toJSON()方法来返回一个安全的JSON值。</div></blockquote><h3 class=\"notion-h notion-h2 notion-default notion-h-indent-0 notion-block-1019f6a7e5d94742a46c33d93ea196a8\" data-id=\"1019f6a7e5d94742a46c33d93ea196a8\"><span><div id=\"1019f6a7e5d94742a46c33d93ea196a8\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#1019f6a7e5d94742a46c33d93ea196a8\" title=\"第1章 异步：现在与将来\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">第1章 异步：现在与将来</span></span></h3><blockquote class=\"notion-quote notion-default notion-block-c05d308d4a3b4e9ea76903fdd9598ecf\"><div>因为它会锁定浏览器UI（按钮、菜单、滚动条等），并阻塞所有的用户交互</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-9f9f682c983646f7b834d0a7c6f85e1b\"><div>任何时候，只要把一段代码包装成一个函数，并指定它在响应某个事件（定时器、鼠标点击、Ajax响应等）时执行，你就是在代码中创建了一个将来执行的块，也由此在这个程序中引入了异步机制。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-004aabe075f44a84967063ea296ff3d3\"><div>最好的选择是在JavaScript调试器中使用断点，而不要依赖控制台输出。次优的方案是把对象序列化到一个字符串中，以强制执行一次“快照”，比如通过JSON.stringify(..)。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-f989fa01f5ba46a1832f6e151e81efde\"><div>JavaScript引擎本身并没有时间的概念，只是一个按需执行JavaScript任意代码片段的环境。“事件”（JavaScript代码执行）调度总是由包含它的环境进行。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-433613f11bbd4358a5c2a4f8bdad8050\"><div>然后浏览器就会设置侦听来自网络的响应，拿到要给你的数据之后，就会把回调函数插入到事件循环，以此实现对这个回调的调度执行。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-4711902b6e884cb5b02baa90effb171c\"><div>setTimeout(..)并没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻的tick会摘下并执行这个回调。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-dd50497d984e4b90ba6ba7895b6fc957\"><div>但现在ES6精确指定了事件循环的工作细节，这意味着在技术上将其纳入了JavaScript引擎的势力范围，而不是只由宿主环境来管理。这个改变的一个主要原因是ES6中Promise的引入，因为这项技术要求对事件循环队列的调度运行能够直接进行精细控制</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-d999cf7303754974a50e938b47fcf0b1\"><div>它们在临时步骤中使用了共享的内存地址X和Y</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-6c8b9b529f2a409fb1e6f012c28b0f69\"><div>JavaScript从不跨线程共享数据</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-3a29607fb8a44ef4804b30ee9b48448b\"><div>这种不确定性是在函数（事件）顺序级别上，而不是多线程情况下的语句顺序级别（或者说，表达式运算顺序级别）。换句话说，这一确定性要高于多线程情况。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-778dc23ed3be48cba539e79553a496dd\"><div>在JavaScript的特性中，这种函数顺序的不确定性就是通常所说的竞态条件（race condition）</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-fc55f60376e84a76ac96b19c87c02267\"><div>可以把并发看作“进程”级（或者任务级）的并行，与运算级的并行（不同处理器上的线程）相对。</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-19de0a1ae36a4678a15a87ae7e8e4574\"><div>交互</div></blockquote><blockquote class=\"notion-quote notion-default notion-block-d0535a561b5b45439ad71ccf356fcde4\"><div>通过简单的协调，就避免了竞态条件引起的不确定性。</div></blockquote></main></div>",
            "url": "https://chenglong.ml/article/js-know-2",
            "title": "你不知道的JavaScript（中卷）",
            "summary": "js",
            "date_modified": "2022-04-06T00:00:00.000Z"
        },
        {
            "content_html": "<div id=\"container\" class=\"max-w-5xl font-medium mx-auto undefined\"><main class=\"notion light-mode notion-page notion-block-448c7d314dfd4e67a9bda795735cad50\"><div class=\"notion-viewport\"></div><div class=\"notion-collection-page-properties\"></div><div class=\"notion-text notion-block-811cd94c5a8f49b8bc39fafc0611fd89\">事实证明 ChatGPT 是足够火爆的，火爆到什么程度呢，其 API 一经推出便获得了 GFW 的认证。在 Twitter 上看到很多人都在为解决无法正常访问 OpenAI 的 API 而苦恼，最常见解决方案是使用一台服务器来进行反向代理，但这样又徒增了一些成本。因为之前在公司的业务上遇到过类似问题，当时老板找到了一个还不错的几乎零成本解决方案，试了一下现在仍然可以用来解决 OpenAI 的 API 无法访问的问题，所以在这里推荐给大家。</div><div class=\"notion-text notion-block-6b025473822f4416916f9b9f12e5b491\">该方案的主要思路是使用 Cloudflare 的 Workers 来代理 OpenAI 的 API 地址，配合自己的域名即可在境内实现访问。因为 Cloudflare Workers 有每天免费 10 万次的请求额度，也有可以免费注册的域名，所以几乎可以说是零成本。而且该方法理论上支持所有被认证的网站，而不只是 OpenAI。</div><div class=\"notion-text notion-block-157a5c34d333455aaf4dbf4b17cf9225\">使用这个方案需要你有以下东西：</div><ul class=\"notion-list notion-list-disc notion-block-bc4ba7220afc45f5a3ef0d2b45c11de8\"><li>一个没有被 GFW 认证的域名（<s>没有的话也可以到 </s><a target=\"_blank\" rel=\"noopener noreferrer\" class=\"notion-link\" href=\"https://www.freenom.com/\"><s>https://www.freenom.com</s></a><s> 免费注册一个，</s> ⚠️据推友提醒，freenom 已暂停新用户注册，但相信对于大家来说注册域名不是啥大问题）</li></ul><ul class=\"notion-list notion-list-disc notion-block-ee7f6344ec7c49f6b454283d608d62e0\"><li>一个 Cloudflare 账号（当然也可以现注册）</li></ul><h3 class=\"notion-h notion-h2 notion-h-indent-0 notion-block-ebd227f08bd14ec180afe036c360cd98\" data-id=\"ebd227f08bd14ec180afe036c360cd98\"><span><div id=\"ebd227f08bd14ec180afe036c360cd98\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#ebd227f08bd14ec180afe036c360cd98\" title=\"太长不看\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">太长不看</span></span></h3><ol start=\"1\" class=\"notion-list notion-list-numbered notion-block-946dd5aca5b64326b6f7c90b72955bbe\"><li>新建一个 Cloudflare Worker</li></ol><ol start=\"2\" class=\"notion-list notion-list-numbered notion-block-37b8079497974c91b702c4e6a51186c7\"><li>将 <a target=\"_blank\" rel=\"noopener noreferrer\" class=\"notion-link\" href=\"https://gist.github.com/noobnooc/d0407b5fb81cff9d36f981170b99d4e6\">https://gist.github.com/noobnooc/d0407b5fb81cff9d36f981170b99d4e6</a> 里的代码粘贴到 Worker 中并部署</li></ol><ol start=\"3\" class=\"notion-list notion-list-numbered notion-block-0875c34e6709445592fcd749ae5f5895\"><li>给 Worker 绑定一个没有被 GFW 认证的域名</li></ol><ol start=\"4\" class=\"notion-list notion-list-numbered notion-block-4dcb40eee39944ff9d17afe21b42abad\"><li>使用自己的域名代替 <code class=\"notion-inline-code\">api.openai.com</code></li></ol><div class=\"notion-text notion-block-3d2ffdbdb8b343bcbfb5cdb369f4332b\">如果具体步骤有问题，可以参考下面的详细版教程。</div><h3 class=\"notion-h notion-h2 notion-h-indent-0 notion-block-58d3f37f7b7c42c6b8f3bbd8e9f43687\" data-id=\"58d3f37f7b7c42c6b8f3bbd8e9f43687\"><span><div id=\"58d3f37f7b7c42c6b8f3bbd8e9f43687\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#58d3f37f7b7c42c6b8f3bbd8e9f43687\" title=\"创建一个 Cloudflare Worker\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">创建一个 Cloudflare Worker</span></span></h3><div class=\"notion-text notion-block-1e351d073c8b4f97b8394471be62e038\">没有 Cloudflare 账号的话可以注册一个，具体注册细节就不多说了。注册或登录到 Cloudflare 的管理界面后，点击侧边栏的 “Workers” 选项，然后点击 “Create a Service” 创建一个 Worker。</div><figure class=\"notion-asset-wrapper notion-asset-wrapper-image notion-block-32ac0e5be0f34af5b262569b7e9bbd50\"><div style=\"position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column\"><img src=\"https://user-images.githubusercontent.com/38027416/222871270-d973e2bd-74f9-4efa-b080-e665903a7bac.png\" alt=\"notion image\" loading=\"lazy\" decoding=\"async\"/></div></figure><div class=\"notion-text notion-block-5d1c7027844c48f5b3724c1cefc0bc49\">然后在创建界面中输入 “Service name” 后点击 “Create Service” 按钮新建 Worker。“Select a starter” 项先不用管。</div><figure class=\"notion-asset-wrapper notion-asset-wrapper-image notion-block-927c5b9922794bb0ade9420d7283e0a0\"><div style=\"position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column\"><img src=\"https://user-images.githubusercontent.com/38027416/222871439-4ac253c6-d87f-434e-a8e8-3d05c652217d.png\" alt=\"notion image\" loading=\"lazy\" decoding=\"async\"/></div></figure><div class=\"notion-text notion-block-d4101f013957422992ec8ad70ebb9b35\">至此 Cloudflare 的 Worker 便创建好了，下面开始修改 Worker 的代码，使其能代理 OpenAI 的 API。</div><h3 class=\"notion-h notion-h2 notion-h-indent-0 notion-block-c534975a97364c6a83d2fb9940567fc3\" data-id=\"c534975a97364c6a83d2fb9940567fc3\"><span><div id=\"c534975a97364c6a83d2fb9940567fc3\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#c534975a97364c6a83d2fb9940567fc3\" title=\"修改 Cloudflare Worker 的代码\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">修改 Cloudflare Worker 的代码</span></span></h3><div class=\"notion-text notion-block-65563d8396be40deb40110c0c42643c9\">在 Worker 的管理界面，点击右上角的 “Quick Edit” 按钮编辑代码 Worker 的代码。</div><figure class=\"notion-asset-wrapper notion-asset-wrapper-image notion-block-4b633ec907dd4dbd84c37dd432b37c42\"><div style=\"position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column\"><img src=\"https://user-images.githubusercontent.com/38027416/222871710-c1d4834e-3bb4-49cf-a9dd-b7dcee258112.png\" alt=\"notion image\" loading=\"lazy\" decoding=\"async\"/></div></figure><div class=\"notion-text notion-block-10fac83f6cb6459f92fc0131c2dd2f7a\">在左侧的代码编辑器中，删除现有的所有代码，然后复制粘贴以下内容到代码编辑器：</div><pre class=\"notion-code\"><div class=\"notion-code-copy\"><div class=\"notion-code-copy-button\"><svg fill=\"currentColor\" viewBox=\"0 0 16 16\" width=\"1em\" version=\"1.1\"><path fill-rule=\"evenodd\" d=\"M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z\"></path><path fill-rule=\"evenodd\" d=\"M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z\"></path></svg></div></div><code class=\"language-javascript\">// Website you intended to retrieve for users.\nconst upstream = &#x27;api.openai.com&#x27;\n\n// Custom pathname for the upstream website.\nconst upstream_path = &#x27;/&#x27;\n\n// Website you intended to retrieve for users using mobile devices.\nconst upstream_mobile = upstream\n\n// Countries and regions where you wish to suspend your service.\nconst blocked_region = []\n\n// IP addresses which you wish to block from using your service.\nconst blocked_ip_address = [&#x27;0.0.0.0&#x27;, &#x27;127.0.0.1&#x27;]\n\n// Whether to use HTTPS protocol for upstream address.\nconst https = true\n\n// Whether to disable cache.\nconst disable_cache = false\n\n// Replace texts.\nconst replace_dict = {\n    &#x27;$upstream&#x27;: &#x27;$custom_domain&#x27;,\n}\n\naddEventListener(&#x27;fetch&#x27;, event =&gt; {\n    event.respondWith(fetchAndApply(event.request));\n})\n\nasync function fetchAndApply(request) {\n    const region = request.headers.get(&#x27;cf-ipcountry&#x27;).toUpperCase();\n    const ip_address = request.headers.get(&#x27;cf-connecting-ip&#x27;);\n    const user_agent = request.headers.get(&#x27;user-agent&#x27;);\n\n    let response = null;\n    let url = new URL(request.url);\n    let url_hostname = url.hostname;\n\n    if (https == true) {\n        url.protocol = &#x27;https:&#x27;;\n    } else {\n        url.protocol = &#x27;http:&#x27;;\n    }\n\n    if (await device_status(user_agent)) {\n        var upstream_domain = upstream;\n    } else {\n        var upstream_domain = upstream_mobile;\n    }\n\n    url.host = upstream_domain;\n    if (url.pathname == &#x27;/&#x27;) {\n        url.pathname = upstream_path;\n    } else {\n        url.pathname = upstream_path + url.pathname;\n    }\n\n    if (blocked_region.includes(region)) {\n        response = new Response(&#x27;Access denied: WorkersProxy is not available in your region yet.&#x27;, {\n            status: 403\n        });\n    } else if (blocked_ip_address.includes(ip_address)) {\n        response = new Response(&#x27;Access denied: Your IP address is blocked by WorkersProxy.&#x27;, {\n            status: 403\n        });\n    } else {\n        let method = request.method;\n        let request_headers = request.headers;\n        let new_request_headers = new Headers(request_headers);\n\n        new_request_headers.set(&#x27;Host&#x27;, upstream_domain);\n        new_request_headers.set(&#x27;Referer&#x27;, url.protocol + &#x27;//&#x27; + url_hostname);\n\n        let original_response = await fetch(url.href, {\n            method: method,\n            headers: new_request_headers,\n            body: request.body\n        })\n\n        connection_upgrade = new_request_headers.get(&quot;Upgrade&quot;);\n        if (connection_upgrade &amp;&amp; connection_upgrade.toLowerCase() == &quot;websocket&quot;) {\n            return original_response;\n        }\n\n        let original_response_clone = original_response.clone();\n        let original_text = null;\n        let response_headers = original_response.headers;\n        let new_response_headers = new Headers(response_headers);\n        let status = original_response.status;\n\t\t\n\t\tif (disable_cache) {\n\t\t\tnew_response_headers.set(&#x27;Cache-Control&#x27;, &#x27;no-store&#x27;);\n\t    }\n\n        new_response_headers.set(&#x27;access-control-allow-origin&#x27;, &#x27;*&#x27;);\n        new_response_headers.set(&#x27;access-control-allow-credentials&#x27;, true);\n        new_response_headers.delete(&#x27;content-security-policy&#x27;);\n        new_response_headers.delete(&#x27;content-security-policy-report-only&#x27;);\n        new_response_headers.delete(&#x27;clear-site-data&#x27;);\n\t\t\n\t\tif (new_response_headers.get(&quot;x-pjax-url&quot;)) {\n            new_response_headers.set(&quot;x-pjax-url&quot;, response_headers.get(&quot;x-pjax-url&quot;).replace(&quot;//&quot; + upstream_domain, &quot;//&quot; + url_hostname));\n        }\n\t\t\n        const content_type = new_response_headers.get(&#x27;content-type&#x27;);\n        if (content_type != null &amp;&amp; content_type.includes(&#x27;text/html&#x27;) &amp;&amp; content_type.includes(&#x27;UTF-8&#x27;)) {\n            original_text = await replace_response_text(original_response_clone, upstream_domain, url_hostname);\n        } else {\n            original_text = original_response_clone.body\n        }\n\t\t\n        response = new Response(original_text, {\n            status,\n            headers: new_response_headers\n        })\n    }\n    return response;\n}\n\nasync function replace_response_text(response, upstream_domain, host_name) {\n    let text = await response.text()\n\n    var i, j;\n    for (i in replace_dict) {\n        j = replace_dict[i]\n        if (i == &#x27;$upstream&#x27;) {\n            i = upstream_domain\n        } else if (i == &#x27;$custom_domain&#x27;) {\n            i = host_name\n        }\n\n        if (j == &#x27;$upstream&#x27;) {\n            j = upstream_domain\n        } else if (j == &#x27;$custom_domain&#x27;) {\n            j = host_name\n        }\n\n        let re = new RegExp(i, &#x27;g&#x27;)\n        text = text.replace(re, j);\n    }\n    return text;\n}\n\nasync function device_status(user_agent_info) {\n    var agents = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;];\n    var flag = true;\n    for (var v = 0; v &lt; agents.length; v++) {\n        if (user_agent_info.indexOf(agents[v]) &gt; 0) {\n            flag = false;\n            break;\n        }\n    }\n    return flag;\n}`</code></pre><div class=\"notion-text notion-block-bbbcf1fb78f14dad850e7ff8ef4fe757\">最后点击编辑器右下角的 “Save and deploy” 按钮部署该代码，在弹出的对话框中继续选择 “Save and deploy” 确认部署。</div><figure class=\"notion-asset-wrapper notion-asset-wrapper-image notion-block-1e6e9296f77740ffb873e5978567eaf4\"><div style=\"position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column\"><img src=\"https://user-images.githubusercontent.com/38027416/222872146-bf4c8f30-307a-4511-9be6-8c19db5cab43.png\" alt=\"notion image\" loading=\"lazy\" decoding=\"async\"/></div></figure><div class=\"notion-text notion-block-3e5ec46eae5f406ea41a09ad079b51ac\">至此，便可以使用该 worker 的地址来代替 OpenAI 的 API 地址了。比如想要请求 ChatGPT 的 API 时，把官方文档中的 <code class=\"notion-inline-code\">https://api.openai.com/v1/chat/completions</code> 替换成 <code class=\"notion-inline-code\">https://openai.workers.dev</code> 即可（注意这个地址并不存在，是需要换成自己刚刚创建的 Worker 的地址）。</div><div class=\"notion-text notion-block-972bc685542e4803aa60e7b2a8846221\">但是你可能会发现，这样做了依然还是没有解决问题，因为 Cloudflare Workers 的 <code class=\"notion-inline-code\">workers.dev</code> 域名也是被 GFW 认证过的🥲。所以我们需要给 Worker 绑定一个自己的域名。</div><h3 class=\"notion-h notion-h2 notion-h-indent-0 notion-block-3652d0b0d7454313910b523d6e4a2af3\" data-id=\"3652d0b0d7454313910b523d6e4a2af3\"><span><div id=\"3652d0b0d7454313910b523d6e4a2af3\" class=\"notion-header-anchor\"></div><a class=\"notion-hash-link\" href=\"#3652d0b0d7454313910b523d6e4a2af3\" title=\"绑定域名\"><svg viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a><span class=\"notion-h-title\">绑定域名</span></span></h3><div class=\"notion-text notion-block-9729df3d1d4d445fb68133163600feb2\">在 Cloudflare Workers 的管理界面中，点击 “Triggers” 选项卡，然后点击 “Custom Domians” 中的 “Add Custom Domain” 按钮以绑定域名。</div><figure class=\"notion-asset-wrapper notion-asset-wrapper-image notion-block-6abca7ec622b4a7fb8c360d928bd5d67\"><div style=\"position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column\"><img src=\"https://user-images.githubusercontent.com/38027416/222872491-026600f5-c04c-49c5-9fdf-4d4abb0b66f7.png\" alt=\"notion image\" loading=\"lazy\" decoding=\"async\"/></div></figure><div class=\"notion-text notion-block-b167932298764215a481b858b3974b60\">输入域名后点击 “Add Custom Domain”，根据提示修改域名的 DNS 记录。因为我的域名是托管在 Cloudflare 上的，所以无需手动更改 DNS 记录，如果域名没有托管在 Cloudfalre 上，可以根据相关提示自行配置。</div><figure class=\"notion-asset-wrapper notion-asset-wrapper-image notion-block-6106290be6354426a6c0c13335b7e926\"><div style=\"position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column\"><img src=\"https://user-images.githubusercontent.com/38027416/222872581-b99c8870-bcc7-4b8d-ba1e-1ad7830ce776.png\" alt=\"notion image\" loading=\"lazy\" decoding=\"async\"/></div></figure><div class=\"notion-text notion-block-390bd656425040a3976b48542e85e3c1\">至此便大功告成。等待片刻，应该就可以通过你自己的域名来代替 OpenAI 的 API 地址了，比如在本文的例子中，想要请求 ChatGPT 的 API ，即是把官方 API 地址 <code class=\"notion-inline-code\">https://api.openai.com/v1/chat/completions</code> 换为我自己的域名 <code class=\"notion-inline-code\">https://openai.nooc.ink/v1/chat/completions</code> ，其他参数均参照官方示例即可。由于 Cloudflare 有每天免费 10 万次的请求额度，所以轻度使用基本是零成本的。⚠️注意请不要使用我这里的 <code class=\"notion-inline-code\">openai.nooc.ink</code>，因为随时可能会被我关闭🤪</div><figure class=\"notion-asset-wrapper notion-asset-wrapper-image notion-block-532e406dec6848f9beb9559fd2170db0\"><div style=\"position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column\"><img src=\"https://user-images.githubusercontent.com/38027416/222873100-8979dd0e-9572-4d6b-92d6-86d012bdd188.png\" alt=\"notion image\" loading=\"lazy\" decoding=\"async\"/></div></figure><div class=\"notion-blank notion-block-62a16d3a469447c993513070c6261663\"> </div></main></div>",
            "url": "https://chenglong.ml/article/proxy-openai",
            "title": "openai使用 Cloudflare Workers 解决 OpenAI 和 ChatGPT 的 API 无法访问的问题",
            "summary": "使用 Cloudflare Workers 解决 OpenAI 和 ChatGPT 的 API 无法访问的问题",
            "date_modified": "2021-07-02T00:00:00.000Z"
        }
    ]
}